---
title: 'Lab 3: Measuring Networks - Community Structure and Assortment'
author: "Tiernan Cahill"
date: "21/06/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Loading Data and Required Packages
We will again be importing the graph objects to be used in this analysis from the serialized RDS format.

We will also need to load a few packages for this lab:

  - `dplyr` for wrangling data
  - `igraph` for modelling and visualizing our network
  - `igraphdata` for sample network data
  - `netseg` for alternative homophily and segregation measures
  
(*Note*: Community detection algorithms can be quite slow for larger networks, so for the purposes of quickly demonstrating multiple approaches, we will use a smaller network provided in the `igraphdata` package, which models friendships among faculty members at a university (Nepusz et al., 2008).)

```{r load, message = FALSE}
library(dplyr)
library(igraph)
library(netseg)

# Add faculty sample data to R environment
data("UKfaculty", package = "igraphdata")
```

# Community Detection
There are a variety of different algorithms available as part of the `igraph` package for detecting the underlying community structure of networks. Most aim to maximise *modularity*, which is defined as the observed proportion of edges occurring within communities compared to what would be expected from a random graph. 

It should be noted that there is no one-size-fits-all approach to community detection. Not all algorithms will identify the optimal configuration, and modularity is known to be an imperfect measure of community structure (e.g., often biased against small communities in networks where large communities are present). All of these approaches also suffer from the limitation that the assigned community memberships are *exhaustive* and *exclusive* &mdash; every node belongs to a community, and to **only** one community.

```{r comm-detect, warning=FALSE}
# Newman and Girvan's (2004) modularity optimization algorithmm based on edge
# betweenness
cluster_edge_betweenness(UKfaculty, directed = T) -> comms.betweenness

# Pons and Latapy's (2005) modularity optimization algorithm based on random 
# walk distances
cluster_walktrap(UKfaculty) -> comms.randomwalk

# Clauset et al.'s (2004) hierarchical agglomerative method designed to improve
# performance on large, sparesly populated graphs (only works for undirected
# networks)
cluster_fast_greedy(as.undirected(UKfaculty)) -> comms.fastgreedy

# Blondel et al.'s (2008) multi-level modularity optimization algorithm (also 
# only works for undirected networks)
cluster_louvain(as.undirected(UKfaculty)) -> comms.louvain
```
All of the community detection algorithms included in `igraph` will output a `communities` object with a similar structure (some elements may depend on the particular algorithm used to generate the object). This object can be used and interpreted in a number of different ways, as shown below.
```{r comm-detect-output}
# Let's take a look at the output from one of the community detection algorithms
print(comms.louvain)

# How many communities are there?
length(comms.louvain)

# Compare this to the output from a different algorithm
length(comms.betweenness)

# How big is each community?
sizes(comms.louvain)

# Which community does each node belong to?
cbind(node = V(UKfaculty), 
      community = membership(comms.betweenness)) %>% 
  head(10)

# Try using the output of a different algorithm
cbind(node = V(UKfaculty), 
      community = membership(comms.randomwalk)) %>% 
  head(10)

# Which nodes are in each community?
communities(comms.randomwalk)

# What about a specific community
communities(comms.randomwalk)[[2]]
```
## Visualizing Community Detection
Once a community structure for a given network has been identified using a community detection algorithm, it can also be incorporated into visualizations of that network. For smaller networks, this can also be a useful way to compare the output of different algorithms to see which have face validity, or align with other attributes of the network.
```{r comm-detect-viz, fig.width = 10}
# Set an RNG seed so that we get consistent layouts
set.seed(9)
l = layout_with_fr(UKfaculty)

# Plot the whole network, colour-coded by the faculty members' departments
plot(UKfaculty,
     layout = l,
     edge.arrow.mode = 0,
     vertex.label = NA,
     vertex.size = 6,
     vertex.color = V(UKfaculty)$Group,
     main = "Faculty at a UK University Grouped by Department")

# Add the results of some community detection algorithms to the visualization
par(mfrow=c(1, 3))

plot(comms.betweenness, UKfaculty,
     layout = l,
     edge.arrow.mode = 0,
     vertex.label = NA,
     vertex.size = 6,
     main = "Edge Betweenness")

plot(comms.randomwalk, UKfaculty,
     layout = l,
     edge.arrow.mode = 0,
     vertex.label = NA,
     vertex.size = 6,
     main = "Random Walks")

plot(comms.louvain, UKfaculty,
     layout = l,
     edge.arrow.mode = 0,
     vertex.label = NA,
     vertex.size = 6,
     main = "Louvain Method")
```
We can also visualize the aggregation/division strategy used by the algorithm by plotting its output as either a *dendrogram* or a *hierarchical cluster*.
```{r comm-detect-viz2, fig.width = 10, fig.height = 12}
par(mfrow = c(2, 1))

# Plot as dendrograms
dendPlot(comms.fastgreedy, mode = "dendrogram", leaflab = "none", horiz = T,
       main = "Fast Greedy Method")

dendPlot(comms.randomwalk, mode = "dendrogram", leaflab = "none", horiz = T,
       main = "Random Walks")

# Plot as hierarchical clusters
dendPlot(comms.fastgreedy, mode = "hclust", labels = F,
       main = "Fast Greedy Method")

dendPlot(comms.randomwalk, mode = "hclust", labels = F,
       main = "Random Walks")
```
# Measures of Community
## Modularity

```{r calc-modularity}
# Calculate the modularity of a given community configuration
modularity(comms.betweenness)

# Now compare the modularity of different algorithmic approaches to 
# community configuration
cbind("modularity" = c(
        "edge betweenness" = modularity(comms.betweenness),
        "fast greedy method" = modularity(comms.fastgreedy),
        "louvain method" = modularity(comms.louvain),
        "random walks" = modularity(comms.randomwalk)))

# Modularity can also be calculated for arbitrary configurations (such as
# faculty department)
modularity(UKfaculty, membership = V(UKfaculty)$Group)
```

## Assortment

```{r calc-assortment}
assortativity_nominal(UKfaculty, V(UKfaculty)$Group, directed = T)
assortativity_degree(UKfaculty, directed = T)

# The netseg package provides a number of additional measures of homophily and
# segregation
ei(UKfaculty, "Group")                      # Krackhard and Stern's E/I Index
freeman(as.undirected(UKfaculty), "Group")  # Freeman's segregation index
coleman(UKfaculty, "Group")                 # Coleman's homophily index
```