---
title: 'Lab 2: Measuring Networks - Centrality and Global Measures'
author: "Tiernan Cahill"
date: "12/06/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Loading Data and Required Packages
Rather than having to re-convert the raw data from Brandwatch into a graph object, we can serialize the existing graph objects from Lab 1 and import them directly into our environment here.

We will also need to load a few packages for this lab:

  - `magrittr` for handling pipes and enabling tidy workflows
  - `dplyr` for wrangling data
  - `igraph` for modelling and visualizing our network

```{r load, message = FALSE}
library(magrittr)
library(dplyr)
library(igraph)

mention_graph <- readRDS("../data/mention_graph.RDS")
htag_graph <- readRDS("../data/htag_graph.RDS")
htag_uses_graph <- readRDS("../data/htag_uses_graph.RDS")
```

# Node-Level Centrality
The `igraph` package has various functions available for calculating various common measures of node-level centrality.

## Degree
The most basic option for calculating centrality is by degree, or the number of adjacent nodes. We will use the `degree` function to demonstrate some of the different ways that centrality measures can be handled in R.
```{r degree}
# Use the degree function to calculate the degree centrality of each node
degree(mention_graph) %>% head()

# Can be applied to the entire network (as above) or to selected nodes
degree(htag_graph, v = c("#michigan", "#pennsylvania", "#wisconsin", 
                         "#minnesota", "#northcarolina", "#arizona"))

# By default, calculates the total degree, but accepts flags for in-degree
# and out-degree in directed networks
pol_users <- c("MissouriGOP", "OHDems",
                     "joebiden", "realdonaldtrump")
data.frame(deg.out = degree(mention_graph, v = pol_users, mode = "out"),
           deg.in = degree(mention_graph, v = pol_users, mode = "in"))
```

```{r degree-append}
# Append degree centrality as a node-level attribute to store within the graph object
V(mention_graph)$deg.out <- degree(mention_graph, mode = "out")
V(mention_graph)$deg.in <- degree(mention_graph, mode = "in")
V(htag_graph)$deg <- degree(htag_graph, mode = "total")

# Let's take a look!
vertex_attr_names(mention_graph)
```

## Strength
*Weighted degree centrality*, also sometimes called *strength*, can be calculated using the `strength` function. All of the uses of the `degree` function shown above can also be applied here, and on unweighted networks, `degree` is automatically called instead.

```{r strength}
# Compare the weighted and unweighted degree centrality for a weighted network
V(htag_graph)$deg.weighted <- strength(htag_graph)

vertex.attributes(htag_graph) %>%
  as.data.frame() %>% head(10)
```

## Betweenness
Likewise, the `betweenness` function can be used to calculate the *betweenness centrality* of each node. Recall that betweenness counts the number of geodesics that pass through a given node. The `betweenness` function take edge weights into consideration by default (if the network is weighted), but this can be disabled by setting `weights = FALSE`.

```{r betweenness}
V(mention_graph)$betweenness <- betweenness(mention_graph, directed = TRUE)

# Let's take a look!
mention_centralities <- vertex.attributes(mention_graph) %>% 
  as.data.frame() %>% 
  select(name, deg.out, deg.in, betweenness)

mention_centralities %>% 
  arrange(desc(betweenness)) %>%
  head(20)
```

# Network-Level Measurements

## Size
```{r size}
gsize(htag_graph)

# For comparison
ecount(htag_graph)

```

## Density
```{r density}
edge_density(mention_graph, loops = F)
```

## Degree Distribution
```{r degree-distribution}
degree_distribution(htag_graph) %>% glimpse()

# Visualize the distribution on a plot
degree_distribution(htag_graph) %>% plot(xlim = c(1, 40), 
                                         type = "o", pch = 19, col = "blue",
                                         xlab = "Degree", 
                                         ylab = "Density",
                                         frame = F)
```

## Components
```{r components}
components(mention_graph, mode = "weak") -> mention_components
components(htag_graph) -> htag_components # Mode ignored for undirected graphs

# Let's take a look
str(mention_components)

# How many (weakly-connected) components does this network have?
count_components(mention_graph)

# How big is the largest component?
max(mention_components$csize)

# Which component is a given node in?
mention_components$membership["dailycaller"]
```
```{r decomposition}
# Decompose a single graph object into separate objects for each component
decompose(mention_graph, mode = "weak") -> mention_graphs

# Let's take a look!
V(mention_graphs[[1]]) %>% head()
V(mention_graphs[[2]]) %>% head()
V(mention_graphs[[3]]) %>% head()
```

## Average Path Length
```{r path-length}
mean_distance(mention_graph, directed = T)
mean_distance(htag_graph, directed = F)

# Can also use related functions to figure out the shortest path between nodes
shortest_paths(mention_graph, 
               from = "dailycaller", to = "realdonaldtrump", 
               mode = "all")$vpath
```

## Diameter
```{r }
```

## Clustering Coefficient / Transitivity
```{r }
```
