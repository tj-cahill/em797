---
title: 'Lab 2: Measuring Networks - Centrality and Global Measures'
author: "Tiernan Cahill"
date: "15/06/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Loading Data and Required Packages
Rather than having to re-convert the raw data from Brandwatch into a graph object, we can serialize the existing graph objects from Lab 1 and import them directly into our environment here.

We will also need to load a few packages for this lab:

  - `dplyr` for wrangling data
  - `igraph` for modelling and visualizing our network

```{r load, message = FALSE}
library(dplyr)
library(igraph)

mention_graph <- readRDS("../data/mention_graph.RDS")
htag_graph <- readRDS("../data/htag_graph.RDS")
htag_uses_graph <- readRDS("../data/htag_uses_graph.RDS")
```

# Node-Level Centrality
The `igraph` package has various functions available for calculating various common measures of node-level centrality.

## Degree
The most basic option for calculating centrality is by degree, or the number of adjacent nodes. We will use the `degree` function to demonstrate some of the different ways that centrality measures can be handled in R.
```{r degree}
# Use the degree function to calculate the degree centrality of each node
degree(mention_graph) %>% head()

# Can be applied to the entire network (as above) or to selected nodes
degree(htag_graph, v = c("#michigan", "#pennsylvania", "#wisconsin", 
                         "#minnesota", "#northcarolina", "#arizona"))

# By default, calculates the total degree, but accepts flags for in-degree
# and out-degree in directed networks
pol_users <- c("MissouriGOP", "OHDems",
                     "joebiden", "realdonaldtrump")
data.frame(deg.out = degree(mention_graph, v = pol_users, mode = "out"),
           deg.in = degree(mention_graph, v = pol_users, mode = "in"))
```

```{r degree-append}
# Append degree centrality as a node-level attribute to store within the graph object
V(mention_graph)$deg.out <- degree(mention_graph, mode = "out")
V(mention_graph)$deg.in <- degree(mention_graph, mode = "in")
V(htag_graph)$deg <- degree(htag_graph, mode = "total")

# Let's take a look!
vertex_attr_names(mention_graph)
```

## Strength
*Weighted degree centrality*, also sometimes called *strength*, can be calculated using the `strength` function. All of the uses of the `degree` function shown above can also be applied here, and on unweighted networks, `degree` is automatically called instead.

```{r strength}
# Compare the weighted and unweighted degree centrality for a weighted network
V(htag_graph)$deg.weighted <- strength(htag_graph)

vertex.attributes(htag_graph) %>%
  as.data.frame() %>% head(10)
```

## Betweenness
Likewise, the `betweenness` function can be used to calculate the *betweenness centrality* of each node. Recall that betweenness counts the number of geodesics that pass through a given node. The `betweenness` function take edge weights into consideration by default (if the network is weighted), but this can be disabled by setting `weights = FALSE`.

```{r betweenness}
V(mention_graph)$betweenness <- betweenness(mention_graph, directed = TRUE)

# Let's take a look!
mention_centralities <- vertex.attributes(mention_graph) %>% 
  as.data.frame() %>% 
  select(name, deg.out, deg.in, betweenness)

mention_centralities %>% 
  arrange(desc(betweenness)) %>%
  head(20)
```

# Network-Level Measurements
The `igraph` package also offers a number of different functions for calculating common network-level parameters that can help to specify the shape and structure of a network.

## Size
The size of a network is simply defined as the number of edges it contains. This can be calculated using the `gsize` function, but note that the output will always be identical to that of the `ecount` function. 
```{r size}
gsize(htag_graph)

# For comparison
ecount(htag_graph)

```

## Density
The *density* of a network is considered to be the ratio of the number of (actual) edges to the number of potential edges. This can be calculated using the `edge_density` function. For the purposes of this calculation, we need to decide whether or not to consider *loop edges* that connect a given node to itself. The function defaults to ignore loops if this is not specified and this is typically appropriate for most networks.
```{r density}
edge_density(mention_graph, loops = F)
```

## Degree Distribution
In addition to calculating the degree centrality at the node level, we may be interested in the distribution of degree centrality throughout the network. For instance, are there a small number of highly-central nodes, or is degree centrality more evenly distributed? The `degree_distribution` function takes the same parameters as `degree` and returns a vector showing the relative frequency of each degree in the network. While this can be useful on its own, for networks with a wide range of degree centralities, it may be more practical to visualize the distribution.
```{r degree-distribution}
degree_distribution(htag_graph) %>% glimpse()

# Visualize the distribution on a plot
degree_distribution(htag_graph) %>% plot(xlim = c(1, 40), 
                                         type = "o", pch = 19, col = "blue",
                                         xlab = "Degree", 
                                         ylab = "Density",
                                         frame = F)
```
We can see from the visualization above that the vast majority of nodes in this network have a low (< 10) degree centrality, with a long tail of various higher degrees also present.

## Diameter
The *diameter* of a network is defined as the length of the longest geodesic (i.e., the shortest path betwen any two nodes). This can be calculated for a graph object using the `diameter` function as shown below. Note that in disconnected networks (i.e., those with more than one component) this will return the diameter of the largest component by default.

In formal graph theory, the weight of edges is incorporated in calculating path length for weighted networks, such that a higher-weighted path between two nodes is treated as "longer" than a lower-weighted path. While this is sometimes appropriate, there are instances in social network analysis where this interpretation of edge weight is counter-intuitive. For example, consider the network of Twitter mentions we have been working with thus far: under the normal procedure for calculating geodesics, a path between two users who frequently tweeted at each other would be considered longer than a path between two users who had interacted only once. In this situation, it may be justifiable to remove the edge weights from the graph object for the purpose of calculating diameter, or the geodesic between two nodes.
```{r diameter}
# Calculate diameter
diameter(htag_graph, directed = F)

# We may want to ignore edge weights when calculating diameter
mention_graph.unweighted <- mention_graph %>% 
  delete_edge_attr("weight")

diameter(mention_graph.unweighted, directed = T)

# Determine the path of the longest geodesic (ignoring weight)
get_diameter(mention_graph.unweighted)
```

## Average Path Length
Similar to diameter, we may be interested in determining the average length of the shortest paths between all pairs of nodes. This can be simply calculated using the `mean_distance` function. (*Note:* This function currently does not consider edge weights, and so it is not necessary to remove them from a graph object when calculating average path length).
```{r path-length}
mean_distance(mention_graph, directed = T) 
mean_distance(htag_graph, directed = F)

# Can also use related functions to figure out the shortest path between nodes
shortest_paths(mention_graph, 
               from = "dailycaller", to = "realdonaldtrump", 
               mode = "all", weights = NA)$vpath
```

## Components
There may be situations in which we want to section a network into *components*. Components are subgraphs of the network which are connected within themselves, but disconnected from each other. In fully-connected networks without isolates, there will be only one component, and many networks have a "big component" structure, where most of the nodes are connected to each other in one large component, with a few smaller disconnected subgraphs adjacent.

Recall that in directed networks, components may be defined as either *strong* or *weak*: A strong component is one in which all of the nodes can be reached by following the directed edges (i.e., *arcs*); a weak component is one in which all of the nodes are connected, but not necessarily following the direction of the edges between them. 
```{r components}
components(mention_graph, mode = "weak") -> mention_components
components(htag_graph) -> htag_components # Mode ignored for undirected graphs

# Let's take a look
str(mention_components)

# How many (weakly-connected) components does this network have?
count_components(mention_graph)

# How big is the largest component?
max(mention_components$csize)

# Which component is a given node in?
mention_components$membership["dailycaller"]
```
There are situations in which we may want to analyze one or more of the component subgraphs of a network as a network in its own right. For instance, we may be interested in determining geodesic paths only between nodes that are actually capable of reaching each other, and which are therefore within the same component (the `diameter` function has actually already done this for us automatically) or we may be interested in isolating a specific component for the purposes of visualization.
```{r decomposition}
# Decompose a single graph object into separate objects for each component
decompose(mention_graph, mode = "weak") -> mention_graphs

# Let's take a look!
V(mention_graphs[[1]]) %>% head()
V(mention_graphs[[2]]) %>% head()
V(mention_graphs[[3]]) %>% head()
```

## Clustering Coefficient
The *clustering coefficient* of a node is defined as the probabilty that the adjacent nodes are connected with each other. `igraph` refers to this property as *transitivity* and offers the `transitivity` function with options that allow us to calculate the clustering coefficient either on a per-node basis or for the network as a whole. (*Note:* This function ignores the direction of edges in directed networks.)
```{r clustering}
transitivity(htag_graph, type = "global")

# Calculate node-level clustering coefficients
V(htag_graph)$clustering <- transitivity(htag_graph, type = "local", isolates = "zero")

# Let's take a look!
vertex_attr(htag_graph, "clustering", "#usps")
```
