---
title: 'Lab 1: Data Formats for Networks'
author: "Tiernan Cahill"
date: "07/06/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, error = FALSE)
```

# Loading Data and Required Packages
Let's begin by importing the raw data from Brandwatch (stored in an Excel file), as well as loading all of the packages we will need for this lab:

  - `readxl` for reading Excel data into an R data frame
  - `dplyr` for wrangling data
  - `stringr` for parsing some messy text in the original dataset
  - `tidyr` for restructuring data
  - `igraph` for modelling and visualizing our network

```{r load, message=FALSE}
library(readxl)
library(dplyr)
library(stringr)
library(tidyr)
library(igraph)

lab <- read_excel("../data/lab.xlsx") %>% 
  rename_all(~str_replace_all(., "\\s+", "")) # Remove whitespace from variable names
```

Looking at the raw data, we can see that there are ```r ncol(lab)``` variable included from Brandwatch, many of which are not relevant to our analysis, or even to this particular context (e.g., `InstagramFollowers`). As we restructure this dataset into various formats for network analysis in the following sections, we will have to pick and choose which variables are necessary in each case. 

# Formats for Representing Networks

## Edge List
The format that most closely resembles the structure of the data we already have is probably an *edge list*. In this case, we have a list of tweets, which we can model as *edges*, with the Twitter users who are either posting or mentioned in each tweet being represented as *nodes*. 

```{r edgelist}
edges <- lab %>%
  select(V1 = Author, V2 = MentionedAuthors) %>%
  separate_rows(V2, sep = ", ") %>%                   # Possibly more than one edge per tweet
  mutate(V2 = str_replace_all(V2, "@", ""))           # Node IDs should be formatted the same in both columns

# Let's take a look!
head(edges)
```

### Weighted Edges
Note that some of these tweets don't mention any other users, and so we have incomplete edges. We can choose to retain these in our network model as *isolates* or to remove them from the dataset. Also, remember that these edges represent a *directed* network. In some cases, there may be more than one tweet between the same pair of users, which we can represent by giving the edge a *weight*.

```{r weighted-edges}
weighted_edges <- edges %>% 
  count(V1, V2, name = "weight")
```

There will now be no duplicate edges in the list, but user pairs who had multiple interactions in the sample will have a higher weight associated with that edge.

### Converting to a Network
To conduct later network analysis on the network model we've created, we will need to convert it into a *graph object* that the tools from the `igraph` package can understand. (Also, this is a good place to point out that `igraph` functions refer to nodes as *vertices*.)
```{r edgelist2graph}
mention_graph <- graph_from_data_frame(weighted_edges, directed = TRUE) %>%
  delete_vertices("NA")  # igraph interprets missing values as a string
```

### Adding Node Attributes
In some situations, we may want a graph object to include attributes associated with the nodes in a network that are not directly related to the network structure (e.g., the number of followers a particular Twitter user has, or the location they have added to their profile). To add these variables to the `igraph` object, we first need to extract them from the existing dataset and make sure that they are appropriately formatted (i.e., in alphabetical order of node ID and without duplicates).

```{r node-attr}
nodes <- lab %>%
  select(id = Author, verified = TwitterVerified, followers = TwitterFollowers, region = Region) %>%
  mutate(verified = as.logical(verified),
         region = as.factor(region))

# Also need to make sure that mentioned users are included, even though we do not have data for them
mentioned_nodes <- lab %>%
  select(id = MentionedAuthors) %>%
  mutate(id = str_replace_all(id, "@", "")) %>%
  separate_rows(id, sep = ", ")

nodes <- nodes %>% 
  bind_rows(mentioned_nodes) %>%
  distinct(id, .keep_all = T) %>%
  arrange(id) %>%
  .[-1,]          # Remove empty row created by isolates

# Before adding variables to the graph object, check and make sure that the lists line up
cbind(names(V(mention_graph)), nodes$id) %>% head()
vcount(mention_graph) == nrow(nodes)

# If the above checks out, set vertex attributes from the node list
mention_graph <- mention_graph %>%
  set_vertex_attr("verified", index = V(mention_graph), nodes$verified) %>%
  set_vertex_attr("followers", index = V(mention_graph), nodes$followers) %>%
  set_vertex_attr("region", index = V(mention_graph), nodes$region)
```

## Adjacacency Matrix
Graph models can also be represented as an *adjacency matrix*.  This format can be especially useful for representing small, densely connected networks, but can get large and unwieldy with large, sparse networks (such as the Twitter mentions we've been looking at). 

It's worth noting that `igraph` can convert back and forth between most major network formats, allowing us to easily produce an adjacency matrix representation from our existing graph object.

```{r graph2matrix}
mention_matrix <- as_adjacency_matrix(mention_graph)
```

In addition to modelling interactions between users, we can also look at co-incidence between hashtags as a network. Below, we have some code that generates an adjacency matrix of hashtags based on the Brandwatch data. Unlike the earlier network of mentions, this one will be *undirected*, since it only indicates that two hashtags appeared together in a tweet and the number of times this occurred in the dataset (represented as the *weight* of that edge).

```{r adj-matrix}
htags <- lapply(lab$Hashtags, str_split, pattern = ", ")
htags <- lapply(htags, unlist, recursive = F)

# Credit to Martin Stefan for the matrix generation code below 
# [https://tinyurl.com/7sd76m8p]

# First create a list of unique tags in the dataset to set the dimensions of the matrix
utags <- unique(unlist(htags))

htag_matrix <- matrix(0, length(utags), length(utags))
rownames(htag_matrix) <- utags
colnames(htag_matrix) <- utags

# Then, iterate through the list of tweets and add to the adjacency matrix
for(t in 1:length(htags)) {
  tags <- htags[[t]]
  
  if(length(tags) == 1) next()
  
  htag_matrix[tags, tags] <- htag_matrix[tags, tags] + 1
}

# Set the diagonal of the matrix to 0 (hashtags are not adjacent to themselves)
diag(htag_matrix) <- 0

# Creat graph object
htag_graph <- graph_from_adjacency_matrix(htag_matrix, mode = "undirected", weighted = TRUE)
```

